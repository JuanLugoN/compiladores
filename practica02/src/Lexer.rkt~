#lang nanopass

;; Bibliotecas chidas para lexear
(require parser-tools/lex
         parser-tools/lex-plt-v200
         (prefix-in : parser-tools/lex-sre);Operadores
         (prefix-in re- parser-tools/lex-sre)
         parser-tools/yacc)
;Exporta todos los identificadores que están definidos en el  nivel
;de fase relevante dentro del módulo de exportación, y que tienen el mismo contexto léxico
(provide (all-defined-out))

;; Tokens con argumentos
(define-tokens a (INTEGER ; Numeros
                  BOOLEAN; Booleanos
                  VAR ; Variables
                  ))

;; Tokens sin argumentos
(define-empty-tokens b (LP LB LK              ;Delimitadores izquierdos
                        RP RB RK              ;Delimitadores derechos
                        + - / *               ;Operadores aritmeticos
                        AND OR                ;Operadores booleanos
                        IF THEN ELSE          ;Condicional
                        BOOL INT              ;Tipos
                        FUN FUNF TYPEOF ARROW ;Funciones
                        APP                   ;Aplicaciones de funciones
                        LET ASSIGN IN END     ;Let
                        EOF                   ;Token final
                        ))

;; sre : S-regular expressions
;; minH-lexer: minHS-lenguage -> Token
(define minHS-lexer
           (lexer
             [(:: (:? #\-) (:+ (char-range #\0 #\9)))
              ; =>
              (token-INTEGER (string->number lexeme))]
             [(:: #\# (:or #\t #\f))
              ; =>
              (token-BOOLEAN (equal? lexeme "#t"))]
             [(:+ (:or (char-range #\a #\z) (char-range #\A #\Z))) ; (a-z | A-Z)^+
              ; =>
              (token-VAR (string->symbol lexeme))]
             [#\(
              ;=>
              (token-LP)]
             [#\)
              ;=>
              (token-RP)]
             [#\[
              ;=>
              (token-LB)]
             [#\]
              ;=>
              (token-RB)]
             [#\{
              ;=>
              (token-LK)]
             [#\}
              ;=>
              (token-RK)]
             [#\+
              ; =>
              (token-+)]
             [#\-
              ; =>
              (token--)]
             [#\/
              ; =>
              (token-/)]
             [#\*
              ; =>
              (token-*)]
             [(:: #\a #\n #\d)
              ; =>
              (token-AND)]
             [(:: #\o #\r)
              ; =>
              (token-OR)]
             [(:: #\i #\f)
              ; =>
              (token-IF)]
             [(:: #\t #\h #\e #\n)
              ; =>
              (token-THEN)]
             [(:: #\e #\l #\s #\e)
              ; =>
              (token-ELSE)]
             [(:: #\B #\o #\o #\l)
              ; =>
              (token-BOOL)]
             [(:: #\I #\n #\t)
              ; =>
              (token-INT)]
             [(:: #\f #\u #\n)
              ; =>
              (token-FUN)]
             [(:: #\f #\u #\n #\F)
              ; =>
              (token-FUNF)]
             [#\:
              ; =>
              (token-TYPEOF)]
             [(:: #\= #\>)
              ; =>
              (token-ARROW)]
             [(:: #\a #\p #\p)
              ; =>
              (token-APP)]
             [(:: #\l #\e #\t)
              ; =>
              (token-LET)]
             [#\=
              ; =>
              (token-ASSIGN)]
             [(:: #\i #\n)
              ; =>
              (token-IN)]
             [(:: #\e #\n #\d)
              ; =>
              (token-END)]
             [whitespace
              ; =>
              (minHS-lexer input-port)] ;Ignoramos espacios en blanco  
             [(eof) ;Token final
              (token-EOF)]))

